# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

target 'AppTunerMobile' do
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  target 'AppTunerMobileTests' do
    inherit! :complete
    # Pods for testing
  end

  post_install do |installer|
    # Generate ExpoModulesProvider.swift — lists all expo modules to register.
    # Update this file manually when adding new expo-* packages.
    swift_file_path = File.join(__dir__, "AppTunerMobile/ExpoModulesProvider.swift")
    swift_content = <<~SWIFT
      // Auto-generated by AppTuner Podfile — update when adding new expo modules.
      import ExpoModulesCore
      import EXAV
      import ExpoBlur
      import ExpoCamera
      import ExpoClipboard
      import EXConstants
      import ExpoContacts
      import ExpoCrypto
      import ExpoDevice
      import ExpoFileSystem
      import ExpoFont
      import ExpoHaptics
      import ExpoImage
      import ExpoLinearGradient
      import ExpoLinking
      import ExpoLocalAuthentication
      import ExpoLocation
      import ExpoMediaLibrary
      import ExpoNetwork
      import ExpoScreenOrientation
      import ExpoSecureStore
      import ExpoSensors
      import ExpoSharing
      import ExpoSpeech
      import ExpoSQLite
      import ExpoStoreReview
      import ExpoWebBrowser

      @objc(ExpoModulesProvider)
      public class ExpoModulesProvider: ModulesProvider {
        public override func getModuleClasses() -> [AnyModule.Type] {
          return [
            VideoViewModule.self,
            BlurViewModule.self,
            CameraViewModule.self,
            ClipboardModule.self,
            ConstantsModule.self,
            ContactsModule.self,
            ContactAccessButtonModule.self,
            CryptoModule.self,
            AesCryptoModule.self,
            DeviceModule.self,
            FileSystemModule.self,
            FontLoaderModule.self,
            FontUtilsModule.self,
            HapticsModule.self,
            ImageModule.self,
            LinearGradientModule.self,
            ExpoLinkingModule.self,
            LocalAuthenticationModule.self,
            LocationModule.self,
            MediaLibraryModule.self,
            NetworkModule.self,
            ScreenOrientationModule.self,
            SecureStoreModule.self,
            AccelerometerModule.self,
            BarometerModule.self,
            DeviceMotionModule.self,
            GyroscopeModule.self,
            MagnetometerModule.self,
            MagnetometerUncalibratedModule.self,
            PedometerModule.self,
            SharingModule.self,
            SpeechModule.self,
            SQLiteModule.self,
            StoreReviewModule.self,
            WebBrowserModule.self,
          ]
        }

        public override func getAppDelegateSubscribers() -> [ExpoAppDelegateSubscriber.Type] {
          return [
            FileSystemBackgroundSessionHandler.self,
            LinkingAppDelegateSubscriber.self,
            ScreenOrientationAppDelegate.self,
          ]
        }

        public override func getReactDelegateHandlers() -> [ExpoReactDelegateHandlerTupleType] {
          return []
        }
      }
    SWIFT
    File.write(swift_file_path, swift_content)
    puts '[AppTuner] Generated ExpoModulesProvider.swift'

    # Add ExpoModulesProvider.swift to the Xcode project if not already present
    project_path = File.join(__dir__, "AppTunerMobile.xcodeproj")
    project = Xcodeproj::Project.open(project_path)
    target = project.targets.find { |t| t.name == "AppTunerMobile" }
    group = project.main_group.find_subpath("AppTunerMobile", false)
    unless group.nil? || group.files.any? { |f| f.path == "ExpoModulesProvider.swift" }
      file_ref = group.new_file("ExpoModulesProvider.swift")
      target.source_build_phase.add_file_reference(file_ref)
      project.save
      puts '[AppTuner] Added ExpoModulesProvider.swift to Xcode project'
    end

    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false
    )

    # Force C++20 at project level so all pod targets pick it up
    installer.pods_project.build_configurations.each do |config|
      config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'gnu++20'
    end

    # Patch folly/Portability.h to disable coroutines (coro headers not shipped in pod)
    portability_h = File.join(installer.sandbox.root,
      'Headers/Public/RCT-Folly/folly/Portability.h')
    if File.exist?(portability_h) && !File.read(portability_h).include?('#define FOLLY_CFG_NO_COROUTINES 1')
      content = File.read(portability_h)
      File.write(portability_h, "#define FOLLY_CFG_NO_COROUTINES 1\n" + content)
      puts '[AppTuner] Patched folly/Portability.h to disable coroutines'
    end

    # Workaround: RN 0.76 + Xcode 16 — SafeAreaViewProps is not generated by
    # codegen (interfaceOnly:true in the spec) but SafeAreaViewShadowNode.h
    # still references it. Patch the empty rncore/Props.h to define the alias.
    props_h = File.join(installer.sandbox.root,
      'Headers/Public/React-FabricComponents/react/renderer/components/rncore/Props.h')
    if File.exist?(props_h) && !File.read(props_h).include?('SafeAreaViewProps')
      File.write(props_h, File.read(props_h).sub(
        "namespace facebook::react {\n\n\n\n} // namespace facebook::react",
        "namespace facebook::react {\n\n#include <react/renderer/components/view/ViewProps.h>\n\nusing SafeAreaViewProps = ViewProps;\n\n} // namespace facebook::react"
      ))
    end
  end
end
